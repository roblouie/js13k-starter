import closurePlugin from '@ampproject/rollup-plugin-closure-compiler';
import { execFileSync } from 'child_process';
import ect from 'ect-bin';
import { statSync } from 'fs';
import { Input, InputAction, InputType, Packer } from 'roadroller';
import { OutputAsset, OutputChunk } from 'rollup';
import { defineConfig, IndexHtmlTransformContext, Plugin } from 'vite';
const htmlMinify = require('html-minifier');
import packageJson from './package.json';

export default defineConfig({
  build: {
    target: 'esnext',
    polyfillModulePreload: false, // Don't add vite polyfills
    cssCodeSplit: false,
    brotliSize: false,
    rollupOptions: {
      output: {
        inlineDynamicImports: true,
        manualChunks: undefined,
      },
    },
  },
  plugins: [
    closurePlugin({
      language_in: 'ECMASCRIPT_NEXT',
      language_out: 'ECMASCRIPT_NEXT',
      compilation_level: 'ADVANCED', // WHITESPACE_ONLY, SIMPLE, ADVANCED
      strict_mode_input: true,
      summary_detail_level: '3',
    }),
    roadrollerPlugin(),
    ectPlugin(),
  ],
});

/**
 * Creates the Roadroller plugin that crunches the JS and CSS.
 * @returns The roadroller plugin.
 */
function roadrollerPlugin(): Plugin {
  return {
    name: 'vite:roadroller',
    transformIndexHtml: {
      enforce: 'post',
      transform: async (html: string, ctx?: IndexHtmlTransformContext): Promise<string> => {
        // Only use this plugin during build
        if (!ctx || !ctx.bundle) {
          return html;
        }

        const options = {
          includeAutoGeneratedTags: true,
          removeAttributeQuotes: true,
          removeComments: true,
          removeRedundantAttributes: true,
          removeScriptTypeAttributes: true,
          removeStyleLinkTypeAttributes: true,
          sortClassName: true,
          useShortDoctype: true,
          collapseWhitespace: true,
          collapseInlineTagWhitespace: true,
          removeEmptyAttributes: true,
          removeOptionalTags: true,
          sortAttributes: true,
        };

        const bundleOutputs = Object.values(ctx.bundle);
        const javascript = bundleOutputs.find(output => output.fileName.endsWith('.js')) as OutputChunk;
        const css = bundleOutputs.find(output => output.fileName.endsWith('.css')) as OutputAsset;
        const otherBundleOutputs = bundleOutputs.filter(output => output !== javascript && output !== css);
        if (otherBundleOutputs.length > 0) {
          otherBundleOutputs.forEach(output => console.warn(`WARN Asset not inlined: ${output.fileName}`));
        }

        const htmlWithTitle = html.replace('{{ packageJsonName }}', packageJson.config?.title ?? '');
        const cssInHtml = css ? embedCss(htmlWithTitle, css) : htmlWithTitle;
        const minifiedHtml = htmlMinify.minify(cssInHtml, options);
        return embedJs(minifiedHtml, javascript);
      },
    },
  };
}

/**
 * Transforms the given JavaScript code into a packed version.
 * @param html The original HTML.
 * @param chunk The JavaScript output chunk from Rollup/Vite.
 * @returns The transformed HTML with the JavaScript embedded.
 */
async function embedJs(html: string, chunk: OutputChunk): Promise<string> {
  const removeScriptTag = html.replace(new RegExp(`<script[^>]*?src=[\./]*${chunk.fileName}[^>]*?></script>`), '');
  const htmlInJs = `document.write('${removeScriptTag}');` + chunk.code.trim();

  const inputs: Input[] = [
    {
      data: htmlInJs,
      type: 'js' as InputType,
      action: 'eval' as InputAction,
    },
  ];
  const options = {};
  const packer = new Packer(inputs, options);
  await packer.optimize(2);
  const { firstLine, secondLine } = packer.makeDecoder();
  return `<script>\n${firstLine}\n${secondLine}\n</script>`;
}

/**
 * Embeds CSS into the HTML.
 * @param html The original HTML.
 * @param asset The CSS asset.
 * @returns The transformed HTML with the CSS embedded.
 */
function embedCss(html: string, asset: OutputAsset): string {
  const reCSS = new RegExp(`<link rel="stylesheet"[^>]*?href="[\./]*${asset.fileName}"[^>]*?>`);
  const code = `<style>${(asset.source as string).trim()}</style>`;
  return html.replace(reCSS, (_) => code);
}

/**
 * Creates the ECT plugin that uses Efficient-Compression-Tool to build a zip file.
 * @returns The ECT plugin.
 */
function ectPlugin(): Plugin {
  return {
    name: 'vite:ect',
    writeBundle: async (): Promise<void> => {
      try {
        const args = ['-strip', '-zip', '-10009', 'dist/index.html', 'dist/i.png'];
        const result = await execFileSync(ect, args);
        console.log('ECT result', result.toString().trim());
        const stats = statSync('dist/index.zip');
        console.log('ZIP size', stats.size);
      } catch (err) {
        console.log('ECT error', err);
      }
    },
  };
}
